
from optparse import OptionParser
import re
import os

__doc__ = """
             This is a script that will convert a MySQL schema generated by say MySQLWorkbench into a schema that can be used for sqlite.
          """

__author__ = 'Jimmy John'
__version__ = '1.0'

ignore_list = [
                 r'SET @.*?\=@@(?P<idv>.*?), (?P=idv)\=.*?\;',
                 r'CREATE SCHEMA IF NOT EXISTS.*?DEFAULT CHARACTER SET.*?\;',
                 r'USE \`.*?\`;',
                 r'SET .*?@.*?\;',
                 r'INDEX .*?',
                 r'ON DELETE NO ACTION,',
                 r'ON DELETE NO ACTION,',
              ]

modify_list = [
                 (r'CREATE  TABLE IF NOT EXISTS (?P<idv>.*?\.).*?\(', ''),
                 (r'REFERENCES (?P<schema>.*?\.).*?', ''),
                 (r'(?P<engine>ENGINE = .*?)\;', ''),
                 (r'(?P<idv>ON DELETE NO ACTION)', ''),
                 (r'(?P<idv>ON UPDATE NO ACTION)',''),
              ]

ignore_list_compiled = []
modify_list_compiled = []

for ele in ignore_list:
 ignore_list_compiled.append(re.compile(ele, re.I))

for ele in modify_list:
   modify_list_compiled.append((re.compile(ele[0], re.I), ele[1]))

# ------------------------------
def translate(line, handle_c):
   """
   accepts a line of input and matches it with regular expressions. If they match any, the line is discarded.
   """

   match = False

   for regexobj in ignore_list_compiled:
      if regexobj.match(line):
         match = True
   
   if match:
      handle_c.write('IGNORED:\n\t %s\n' % line)
      return ''

   for regextuple in modify_list_compiled:
       
      try:
         schema = regextuple[0].match(line).group(1)
      except:
         continue
    
      handle_c.write('MODIFIED:\n\t %s => %s\n' % (line, re.sub(schema, regextuple[1], line)))
      return '\n%s' % re.sub(schema, regextuple[1], line)

   return '\n%s' % line

# -------------------
def process(options):
   """
   iterates through each line in the input file and ignores, deletes (if not applicable to sqlite) or translates into valid sqlite
   """

   handle_s = open(options.source, 'r')
   handle_d = open(options.destination, 'w')
   handle_c = open(options.changes, 'w')

   for line in handle_s:
         handle_d.write('%s' % translate(line.strip(), handle_c))

   handle_c.close()
   handle_d.close()
   handle_s.close()

# ----------
def main():
   """
   accept the cmd line args and do necessary error checking
   """

   #read in args
   usage = 'usage: %prog [options]'   
   parser = OptionParser(usage)

   parser.add_option("-s", "--source", dest="source", default="mysql_schema_mysql2sqlite.txt",
                      help="name of file containing the MySQL schema as exported by MySQLWorkbench [default: %default]")

   parser.add_option("-d", "--dest", dest="destination", default="sqlite_schema_mysql2sqlite.txt",
                      help="name of target file to contain the sql schema that can be used in Sqlite [default: %default]")

   parser.add_option("-c", "--change", dest="changes", default="changes_schema_mysql2sqlite.txt",
                      help="differences b/w the two schemas. Lines from source can be IGNORED or MODIFIED [default: %default]")

   (options, args) = parser.parse_args()

   #check if i/p file exists
   if not os.path.exists(options.source):
      parser.error('input filename %s not found' % options.source)

   process(options)

# --------------------------
if __name__ == '__main__':
   main()

